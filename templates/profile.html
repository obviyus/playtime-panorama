<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<link rel="preconnect" href="https://cdn.steamstatic.com" crossorigin>
	<title>Steam collage</title>
	<style>
		:root {
			color-scheme: dark;
			font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
			background: radial-gradient(circle at top left, #0e101d, #010208 65%);
			color: #f5f7ff;
		}

		html,
		body {
			height: 100%;
			width: 100%;
			margin: 0;
			overflow-x: hidden;
			overflow-y: auto;
			color: #f5f7ff;
		}

		body {
			font: inherit;
			overscroll-behavior: contain;
		}

		main {
			width: 100vw;
			min-height: 100vh;
			display: block;
			position: relative;
			padding: 0;
			box-sizing: border-box;
		}

		.games-stage {
			position: relative;
			width: 100%;
			margin: 0;
			overflow: visible;
			padding: 0;
			box-sizing: border-box;
		}

		#status {
			position: fixed;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			pointer-events: none;
			background: radial-gradient(circle at center, rgba(10, 12, 22, 0.55), rgba(6, 8, 16, 0.85));
			transition: opacity 220ms ease, visibility 220ms ease;
			z-index: 20;
			text-align: center;
			padding: 1.25rem;
		}

		#status::after {
			content: '';
			width: clamp(1.8rem, 3vw, 2.6rem);
			aspect-ratio: 1;
			border-radius: 50%;
			border: 3px solid rgba(159, 175, 255, 0.35);
			border-top-color: rgba(159, 175, 255, 0.88);
			animation: spin 0.9s linear infinite;
		}

		#status.hidden {
			opacity: 0;
			visibility: hidden;
		}

		#status.error {
			background: radial-gradient(circle at center, rgba(45, 6, 12, 0.7), rgba(9, 1, 3, 0.85));
		}

		#status.error::after {
			border-color: rgba(255, 126, 142, 0.25);
			border-top-color: rgba(255, 126, 142, 0.9);
		}

		#status.has-message::after {
			display: none;
		}

		.games-grid {
			position: relative;
			width: 100%;
			display: grid;
			margin: 0;
			padding: 0;
			gap: 0;
			grid-auto-flow: dense;
			grid-template-columns: repeat(var(--columns, 1), minmax(0, 1fr));
			grid-auto-rows: var(--row-size, 100px);
			background: transparent;
			box-sizing: border-box;
		}

		.game-card {
			position: relative;
			width: 100%;
			height: 100%;
			display: flex;
			align-items: stretch;
			justify-content: stretch;
			overflow: hidden;
			background: #05060f;
			transition: transform 160ms ease, box-shadow 160ms ease;
			box-shadow: 0 0 0 rgba(0, 0, 0, 0);
		}

		.game-card img {
			display: block;
			width: 100%;
			height: 100%;
			image-rendering: auto;
			object-fit: contain;
			transform-origin: center bottom;
			transition: transform 160ms ease;
		}

		.game-card:hover {
			z-index: 10;
			transform: translateY(-2px);
			box-shadow: 0 10px 18px rgba(0, 0, 0, 0.3);
		}

		.game-card:hover img {
			transform: scale(1.04);
		}

		.game-card::after {
			content: attr(data-hours);
			position: absolute;
			inset: auto 0 0 0;
			padding: 0.35rem 0.4rem;
			background: linear-gradient(180deg, rgba(4, 5, 12, 0) 0%, rgba(4, 5, 12, 0.85) 60%);
			color: rgba(245, 247, 255, 0.92);
			font-size: clamp(0.55rem, 1.1vw, 0.8rem);
			line-height: 1.1;
			opacity: 0;
			transform: translateY(6px);
			transition: opacity 120ms ease, transform 120ms ease;
			text-align: center;
			pointer-events: none;
		}

		.game-card:hover::after,
		.game-card:focus-visible::after {
			opacity: 1;
			transform: translateY(0);
		}

		@keyframes spin {
			to {
				transform: rotate(360deg);
			}
		}
	</style>
</head>

<body>
	<div id="status"></div>
	<main>
		<div class="games-stage" id="games-stage">
			<section class="games-grid" id="games"></section>
		</div>
	</main>
	<script type="module">
		const STEAM_CDN_BASE = "https://cdn.steamstatic.com/steam/apps";

		const getSteamIdFromPath = () => {
			const raw = window.location.pathname.slice(1);
			if (!raw) {
				return "";
			}
			try {
				return decodeURIComponent(raw);
			} catch {
				return raw;
			}
		};

		const steamID = getSteamIdFromPath();

		if (steamID) {
			document.title = `${steamID}'s Steam collage`;
		}
		const statusEl = document.getElementById('status');
		const stageEl = document.getElementById('games-stage');
		const gamesContainer = document.getElementById('games');
		const HEADER_ASPECT = 460 / 215;
		let sourceGames = [];
		let resizeFrame = 0;

		const px = (value) => Math.round(value * 100) / 100 + 'px';

		const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

		const computeGridLayout = (items, stageWidth, stageHeight) => {
			if (!items.length || stageWidth <= 0) {
				return {
					columns: 1,
					rowHeight: 0,
					cells: [],
				};
			}

			const hoursMax = items.reduce((max, item) => Math.max(max, item.hours), 0);
			const logMax = hoursMax > 0 ? Math.log1p(hoursMax) : 1;

			const TARGET_CARD_WIDTH = 44;
			const MAX_CARD_WIDTH = 240;
			const minColumnsBound = Math.max(
				4,
				Math.ceil(stageWidth / MAX_CARD_WIDTH),
			);
			const maxColumnsBound = Math.max(minColumnsBound, Math.min(72, items.length));
			const stageBaseHeight =
				stageHeight && stageHeight > 0 ? stageHeight : (window.innerHeight || 0);
			const maxHeight = Math.max(stageBaseHeight || 0, 480);
			const targetHeight =
				stageBaseHeight && stageBaseHeight > 0
					? stageBaseHeight * 0.94
					: maxHeight;

			let columns = clamp(
				Math.round(stageWidth / TARGET_CARD_WIDTH),
				minColumnsBound,
				maxColumnsBound,
			);

			let layout = { columns, rowHeight: 0, cells: [] };
			let bestLayout = null;
			const MAX_ITERATIONS = 8;
			const weightBias = 0.1;
			const weightExponent = 0.62;
			const disparityCurve = 1.35;

			for (let iteration = 0; iteration < MAX_ITERATIONS; iteration++) {
				const columnWidth = stageWidth / columns;
				const rowHeight = Math.max(columnWidth / HEADER_ASPECT, 10);
				const computedMaxSpan = Math.floor(columns / 6) + 3;
				const maxSpan = clamp(computedMaxSpan, 4, Math.min(columns, 12));
				const minSpan = 1;
				const maxArea = maxSpan * maxSpan;

				const areaWeights = items.map((item) =>
					Math.pow(Math.max(item.hours, 0) + weightBias, weightExponent),
				);
				const maxWeight = areaWeights.reduce(
					(max, weight) => Math.max(max, weight),
					0.0001,
				);

				const cells = items.map((item, index) => {
					const weight = areaWeights[index];
					const ratio = Math.max(0, weight / maxWeight);
					const adjusted = Math.pow(ratio, disparityCurve);
					const targetArea = 1 + adjusted * (maxArea - 1);
					const span = clamp(Math.round(Math.sqrt(targetArea)), minSpan, maxSpan);
					return { id: item.id, span, order: index, areaRatio: ratio };
				});

				if (cells.length && maxSpan > 1) {
					cells[0].span = Math.max(cells[0].span, maxSpan);
					for (let i = 1; i < Math.min(3, cells.length); i++) {
						const cell = cells[i];
						if (cell.areaRatio >= 0.5) {
							const target = Math.round(
								minSpan + cell.areaRatio * (maxSpan - minSpan),
							);
							cell.span = clamp(target, cell.span, maxSpan - i);
						}
					}
				}

				const totalArea = cells.reduce((acc, cell) => acc + cell.span * cell.span, 0);
				const approxHeight =
					(totalArea * stageWidth) / (columns * columns * HEADER_ASPECT);

				const maxColumnsAllowed = maxColumnsBound;
				const candidateLayout = { columns, rowHeight, cells };

				if (approxHeight > maxHeight * 1.02 && columns < maxColumnsAllowed) {
					const requiredColumns = clamp(
						Math.round(
							Math.sqrt(
								(totalArea * stageWidth) / (maxHeight * HEADER_ASPECT),
							),
						),
						columns + 1,
						maxColumnsAllowed,
					);

					if (requiredColumns !== columns) {
						bestLayout = candidateLayout;
						columns = requiredColumns;
						continue;
					}
				}

				if (
					stageBaseHeight > 0 &&
					approxHeight < targetHeight * 0.82 &&
					columns > minColumnsBound
				) {
					const desiredColumns = clamp(
						Math.round(
							Math.sqrt(
								(totalArea * stageWidth) / (targetHeight * HEADER_ASPECT),
							),
						),
						minColumnsBound,
						columns - 1,
					);
					if (desiredColumns !== columns) {
						bestLayout = candidateLayout;
						columns = desiredColumns;
						continue;
					}
				}

				layout = candidateLayout;
				break;
			}

			if ((!layout.cells.length || layout.rowHeight <= 0) && bestLayout) {
				layout = bestLayout;
			}

			return layout;
		};

		const getStageDimensions = () => {
			const rect = stageEl?.getBoundingClientRect();
			const style = stageEl ? window.getComputedStyle(stageEl) : null;
			const paddingX = style
				? parseFloat(style.paddingLeft || '0') + parseFloat(style.paddingRight || '0')
				: 0;
			const paddingY = style
				? parseFloat(style.paddingTop || '0') + parseFloat(style.paddingBottom || '0')
				: 0;

			const innerWidth = Math.max((rect?.width || window.innerWidth || 0) - paddingX, 1);
			const innerHeight = Math.max((rect?.height || window.innerHeight || 0) - paddingY, 1);

			return {
				width: Math.floor(innerWidth),
				height: Math.floor(innerHeight),
			};
		};

		const placeGames = () => {
			if (!gamesContainer || !stageEl) {
				return;
			}

			const playable = sourceGames
				.filter((game) => typeof game?.appid === 'number')
				.sort((a, b) => (b.playtime_forever ?? 0) - (a.playtime_forever ?? 0));

			if (!playable.length) {
				statusEl?.classList.add('error');
				statusEl?.classList.remove('hidden');
				gamesContainer.replaceChildren();
				return;
			}

			const { width: stageWidth, height: stageHeight } = getStageDimensions();

			const items = playable.map((game) => ({
				id: game.appid,
				hours: Math.max(game.playtime_forever ?? 0, 0) / 60,
			}));

			const layout = computeGridLayout(items, stageWidth, stageHeight);

			if (!layout.cells.length || layout.rowHeight <= 0) {
				statusEl?.classList.add('error');
				statusEl?.classList.remove('hidden');
				return;
			}

			const gameById = new Map(playable.map((game) => [game.appid, game]));
			const fragment = document.createDocumentFragment();

			for (const cell of layout.cells) {
				const game = gameById.get(cell.id);
				if (!game) {
					continue;
				}

				const card = document.createElement('article');
				card.className = 'game-card';
				card.style.gridColumn = `span ${cell.span}`;
				card.style.gridRow = `span ${cell.span}`;
				const hours = Math.max(game.playtime_forever ?? 0, 0) / 60;
				card.dataset.hours = `${hours.toLocaleString(undefined, {
					maximumFractionDigits: hours < 10 ? 1 : 0,
				})} hrs`;

				const img = document.createElement('img');
				img.loading = 'eager';
				img.decoding = 'async';
				img.src = `${STEAM_CDN_BASE}/${game.appid}/header.jpg`;
				img.alt = game.name ?? `App ${game.appid}`;

				card.append(img);
				fragment.append(card);
			}

			gamesContainer.style.setProperty('--columns', String(layout.columns));
			gamesContainer.style.setProperty('--row-size', px(layout.rowHeight));
			gamesContainer.replaceChildren(fragment);
			statusEl?.classList.remove('error');
			statusEl?.classList.remove('has-message');
			statusEl?.classList.add('hidden');
			if (statusEl) {
				statusEl.textContent = '';
			}
		};

		const showLoader = () => {
			statusEl?.classList.remove('error');
			statusEl?.classList.remove('has-message');
			statusEl?.classList.remove('hidden');
			if (statusEl) {
				statusEl.textContent = '';
			}
		};

		const renderGames = (games) => {
			sourceGames = Array.isArray(games) ? games : [];
			if (!sourceGames.length) {
				showError('No playtime data found for this SteamID or username.');
				return;
			}
			placeGames();
		};

		window.addEventListener('resize', () => {
			if (!sourceGames.length) {
				return;
			}

			cancelAnimationFrame(resizeFrame);
			resizeFrame = requestAnimationFrame(placeGames);
		});

		const showError = (message) => {
			console.error(message);
			statusEl?.classList.add('error');
			statusEl?.classList.remove('hidden');
			if (statusEl) {
				statusEl.classList.add('has-message');
				statusEl.textContent = message;
			}
		};

		if (!steamID) {
			showError('Add a SteamID or username to the URL (e.g. /76561198000000000 or /obviyus) to view your collage.');
		} else {
			try {
				showLoader();
				const response = await fetch(`/api/playtime/${encodeURIComponent(steamID)}`, {
					headers: {
						Accept: 'application/json',
					},
				});

				if (!response.ok) {
					const errorBody = await response.json().catch(() => ({}));
					throw new Error(errorBody.error || 'Failed to load playtime data.');
				}

				const payload = await response.json();
				renderGames(payload.games ?? []);
			} catch (error) {
				console.error(error);
				showError('We could not load the playtime data. Double-check the SteamID or username, or try again soon.');
			}
		}
	</script>
</body>

</html>