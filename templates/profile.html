<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>__STEAM_ID_HTML__'s Steam collage</title>
	<style>
		:root {
			color-scheme: dark;
			font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
			background: radial-gradient(circle at top left, #0e101d, #010208 65%);
			color: #f5f7ff;
		}

	html,
	body {
			min-height: 100%;
			width: 100%;
			margin: 0;
			overflow-x: hidden;
			background: #05060d;
			color: #f5f7ff;
		}

		body {
			font: inherit;
			overflow-y: auto;
			overscroll-behavior: contain;
		}

		main {
			width: 100vw;
			min-height: 100vh;
			display: block;
			position: relative;
			padding: clamp(12px, 2.4vw, 32px);
			box-sizing: border-box;
		}

		.games-stage {
			position: relative;
			width: 100%;
			max-width: 1920px;
			margin: 0 auto;
			overflow: visible;
			padding: 0;
			box-sizing: border-box;
		}

		#status {
			position: fixed;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			pointer-events: none;
			background: radial-gradient(circle at center, rgba(10, 12, 22, 0.55), rgba(6, 8, 16, 0.85));
			transition: opacity 220ms ease, visibility 220ms ease;
			z-index: 20;
		}

		#status::after {
			content: '';
			width: clamp(1.8rem, 3vw, 2.6rem);
			aspect-ratio: 1;
			border-radius: 50%;
			border: 3px solid rgba(159, 175, 255, 0.35);
			border-top-color: rgba(159, 175, 255, 0.88);
			animation: spin 0.9s linear infinite;
		}

		#status.hidden {
			opacity: 0;
			visibility: hidden;
		}

		#status.error {
			background: radial-gradient(circle at center, rgba(45, 6, 12, 0.7), rgba(9, 1, 3, 0.85));
		}

		#status.error::after {
			border-color: rgba(255, 126, 142, 0.25);
			border-top-color: rgba(255, 126, 142, 0.9);
		}

		.games-grid {
			position: relative;
			width: 100%;
			min-height: 50vh;
			overflow: visible;
			background: transparent;
			contain: layout paint style;
		}

		.game-card {
			position: absolute;
			top: 0;
			left: 0;
			overflow: hidden;
			will-change: transform;
		}

		.game-card img {
			display: block;
			width: 100%;
			height: 100%;
			object-fit: cover;
			image-rendering: auto;
		}

		@keyframes spin {
			to {
				transform: rotate(360deg);
			}
		}
	</style>
</head>

<body>
	<div id="status"></div>
	<main>
		<div class="games-stage" id="games-stage">
			<section class="games-grid" id="games"></section>
		</div>
	</main>
	<script type="module">
		const STEAM_CDN_BASE = __STEAM_CDN_BASE__;
		const steamID = __STEAM_ID_JSON__;
		const statusEl = document.getElementById('status');
		const stageEl = document.getElementById('games-stage');
		const gamesContainer = document.getElementById('games');
		const HEADER_WIDTH = 460;
		const HEADER_HEIGHT = 215;
		const HEADER_RATIO = HEADER_WIDTH / HEADER_HEIGHT;
		const TILE_GAP = 12;
		const SCALE_FLOOR = 0.24;
		const SCALE_POWER = 0.55;
		const MAX_SPAN_BASE = 5;
		let sourceGames = [];
		let resizeFrame = 0;

		const px = (value) => Math.round(value * 100) / 100 + 'px';

		const layoutScaledMasonry = (items, width, gap = TILE_GAP) => {
			if (!items.length || width <= 0) {
				return { boxes: [], width: Math.max(width, 0), height: 0 };
			}

			const sanitizedGap = Math.max(0, gap);
			const maxHours = items.reduce((acc, item) => Math.max(acc, item.hours || 0), 0);

			if (maxHours <= 0) {
				const fallbackWidth = Math.min(HEADER_WIDTH, Math.max(width, 0));
				const fallbackHeight = fallbackWidth / HEADER_RATIO;
				const boxes = items.map((_, index) => ({
					index,
					x: 0,
					y: index * (fallbackHeight + sanitizedGap),
					w: fallbackWidth,
					h: fallbackHeight,
				}));

				const totalHeight = boxes.length
					? boxes[boxes.length - 1].y + boxes[boxes.length - 1].h
					: 0;

				return {
					boxes,
					width: fallbackWidth,
					height: totalHeight,
				};
			}

			const baseMaxSpan = Math.max(1, Math.round(MAX_SPAN_BASE));
			const desiredUnit =
				(HEADER_WIDTH - sanitizedGap * (baseMaxSpan - 1)) / baseMaxSpan;
			let columns = Math.floor((width + sanitizedGap) / (desiredUnit + sanitizedGap));

			if (!Number.isFinite(columns) || columns < baseMaxSpan) {
				columns = baseMaxSpan;
			}

			while (columns > 1) {
				const unitCandidate = (width - (columns - 1) * sanitizedGap) / columns;
				if (unitCandidate > 0) {
					break;
				}
				columns -= 1;
			}

			const maxSpan = Math.min(baseMaxSpan, Math.max(columns, 1));
			const rawUnitWidth =
				(width - Math.max(0, columns - 1) * sanitizedGap) / Math.max(columns, 1);
			const maxUnitByHeader =
				maxSpan > 0
					? (HEADER_WIDTH - sanitizedGap * (maxSpan - 1)) / maxSpan
					: rawUnitWidth;
			const unitWidth = Math.max(1, Math.min(rawUnitWidth, maxUnitByHeader));
			const layoutWidth =
				columns * unitWidth + Math.max(0, columns - 1) * sanitizedGap;
			const offsetX = Math.max(0, (width - layoutWidth) / 2);
			const maxTileWidth =
				maxSpan * unitWidth + Math.max(0, maxSpan - 1) * sanitizedGap;
			const columnHeights = new Array(Math.max(columns, 1)).fill(0);
			const boxes = [];

			items.forEach((item, index) => {
				const normalized = Math.max(0, item.hours) / maxHours;
				const weighted = normalized > 0 ? Math.pow(normalized, SCALE_POWER) : 0;
				const scale = Math.max(SCALE_FLOOR, weighted);
				const idealWidth = Math.min(
					maxTileWidth,
					Math.max(unitWidth, maxTileWidth * scale),
				);

				let span = Math.max(
					1,
					Math.round((idealWidth + sanitizedGap) / (unitWidth + sanitizedGap)),
				);
				span = Math.min(span, maxSpan);
				span = Math.min(span, columnHeights.length);

				let bestStart = 0;
				let bestHeight = Number.POSITIVE_INFINITY;

				for (let start = 0; start <= columnHeights.length - span; start++) {
					let columnHeight = 0;
					for (let offset = 0; offset < span; offset++) {
						columnHeight = Math.max(columnHeight, columnHeights[start + offset]);
					}
					if (columnHeight < bestHeight) {
						bestHeight = columnHeight;
						bestStart = start;
					}
				}

				const x = offsetX + bestStart * (unitWidth + sanitizedGap);
				const tileWidth = span * unitWidth + Math.max(0, span - 1) * sanitizedGap;
				const tileHeight = tileWidth / HEADER_RATIO;
				const y = bestHeight;

				for (let offset = 0; offset < span; offset++) {
					columnHeights[bestStart + offset] = y + tileHeight + sanitizedGap;
				}

				boxes.push({
					index,
					x,
					y,
					w: tileWidth,
					h: tileHeight,
				});
			});

			const layoutHeight =
				boxes.length > 0
					? Math.max(...columnHeights) - sanitizedGap
					: 0;

			return {
				boxes,
				width: width,
				height: Math.max(0, layoutHeight),
			};
		};

		const getStageDimensions = () => {
			const rect = stageEl?.getBoundingClientRect();
			const style = stageEl ? window.getComputedStyle(stageEl) : null;
			const paddingX = style
				? parseFloat(style.paddingLeft || '0') + parseFloat(style.paddingRight || '0')
				: 48;
			const paddingY = style
				? parseFloat(style.paddingTop || '0') + parseFloat(style.paddingBottom || '0')
				: 48;

			const innerWidth = Math.max((rect?.width || window.innerWidth || 0) - paddingX, 1);
			const innerHeight = Math.max((rect?.height || window.innerHeight || 0) - paddingY, 1);

			return {
				width: Math.floor(innerWidth),
				height: Math.floor(innerHeight),
			};
		};

		const placeGames = () => {
			if (!gamesContainer || !stageEl) {
				return;
			}

			const playable = sourceGames
				.filter((game) => typeof game?.appid === 'number')
				.sort((a, b) => (b.playtime_forever ?? 0) - (a.playtime_forever ?? 0));

			if (!playable.length) {
				statusEl?.classList.add('error');
				statusEl?.classList.remove('hidden');
				gamesContainer.replaceChildren();
				return;
			}

			const { width } = getStageDimensions();

			const items = playable.map((game) => ({
				id: game.appid,
				hours: Math.max(game.playtime_forever ?? 0, 0) / 60,
			}));

			const { boxes, width: layoutWidth, height: layoutHeight } = layoutScaledMasonry(
				items,
				width,
				TILE_GAP,
			);

			if (!boxes.length) {
				statusEl?.classList.add('error');
				statusEl?.classList.remove('hidden');
				return;
			}

			const fragment = document.createDocumentFragment();

			for (const box of boxes) {
				const game = playable[box.index];
				if (!game) {
					continue;
				}

				const card = document.createElement('article');
				card.className = 'game-card';
				card.style.width = px(box.w);
				card.style.height = px(box.h);
				card.style.transform = `translate3d(${px(box.x)}, ${px(box.y)}, 0)`;

				const img = document.createElement('img');
				img.loading = 'eager';
				img.decoding = 'async';
				img.src = `${STEAM_CDN_BASE}/${game.appid}/header.jpg`;
				img.alt = game.name ?? `App ${game.appid}`;

				card.append(img);
				fragment.append(card);
			}

			gamesContainer.style.width = px(Math.max(layoutWidth, width));
			gamesContainer.style.height = px(layoutHeight);
			gamesContainer.replaceChildren(fragment);
			statusEl?.classList.remove('error');
			statusEl?.classList.add('hidden');
		};

		const renderGames = (games) => {
			sourceGames = Array.isArray(games) ? games : [];
			if (!sourceGames.length) {
				statusEl?.classList.add('error');
				statusEl?.classList.remove('hidden');
				return;
			}
			placeGames();
		};

		window.addEventListener('resize', () => {
			if (!sourceGames.length) {
				return;
			}

			cancelAnimationFrame(resizeFrame);
			resizeFrame = requestAnimationFrame(placeGames);
		});

		const showError = (message) => {
			console.error(message);
			statusEl?.classList.add('error');
			statusEl?.classList.remove('hidden');
		};

		try {
			const response = await fetch(`/api/playtime/${encodeURIComponent(steamID)}`, {
				headers: {
					Accept: 'application/json',
				},
			});

			if (!response.ok) {
				const errorBody = await response.json().catch(() => ({}));
				throw new Error(errorBody.error || 'Failed to load playtime data.');
			}

			const payload = await response.json();
			renderGames(payload.games ?? []);
		} catch (error) {
			console.error(error);
			showError('We could not load the playtime data. Double-check the SteamID or try again soon.');
		}
	</script>
</body>

</html>
